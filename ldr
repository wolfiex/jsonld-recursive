#!/usr/bin/env node

const jsonld = require('jsonld');
const https = require('https');
const http = require('http');
const { spawn } = require('child_process');
const path = require('path');
const fs = require('fs');
const { expandRecursive, compactJsonLd } = require('./lib/ldr-core');

const PID_FILE = path.join(__dirname, '.ldr-server.pid');

// Document loader
async function documentLoader(url) {
  return new Promise((resolve, reject) => {
    const client = url.startsWith('https:') ? https : http;
    
    client.get(url, { headers: { 'Accept': 'application/ld+json, application/json' } }, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        try {
          resolve({
            contextUrl: null,
            document: JSON.parse(data),
            documentUrl: url
          });
        } catch (error) {
          reject(new Error(`Failed to parse JSON from ${url}: ${error.message}`));
        }
      });
    }).on('error', reject);
  });
}

jsonld.documentLoader = documentLoader;

function isServerRunning() {
  if (!fs.existsSync(PID_FILE)) return false;
  
  try {
    const pid = parseInt(fs.readFileSync(PID_FILE, 'utf8'));
    process.kill(pid, 0);
    return true;
  } catch (e) {
    fs.unlinkSync(PID_FILE);
    return false;
  }
}

async function startServer(port = 3000, mappingsFile = null) {
  const serverPath = path.join(__dirname, 'ldr-server.js');
  const env = { ...process.env, PORT: port.toString() };
  
  if (mappingsFile) {
    env.MAPPINGS_FILE = mappingsFile;
  }
  
  const proc = spawn('node', [serverPath], {
    detached: true,
    stdio: 'ignore',
    env
  });
  
  proc.unref();
  fs.writeFileSync(PID_FILE, proc.pid.toString());
  
  // Wait for server
  for (let i = 0; i < 20; i++) {
    await new Promise(resolve => setTimeout(resolve, 500));
    if (await checkServer()) {
      return proc.pid;
    }
  }
  
  throw new Error('Server failed to start');
}

async function checkServer() {
  return new Promise((resolve) => {
    const req = http.get('http://localhost:3000/health', (res) => {
      resolve(res.statusCode === 200);
    });
    req.on('error', () => resolve(false));
    req.end();
  });
}

async function useServer(url, depth, operation) {
  const response = await new Promise((resolve, reject) => {
    const data = JSON.stringify({ url, depth });
    const options = {
      hostname: 'localhost',
      port: 3000,
      path: `/${operation}`,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Content-Length': data.length
      }
    };
    
    const req = http.request(options, (res) => {
      let body = '';
      res.on('data', chunk => body += chunk);
      res.on('end', () => resolve(JSON.parse(body)));
    });
    
    req.on('error', reject);
    req.write(data);
    req.end();
  });
  
  return response.result;
}

async function apiRequest(method, endpoint, body = null) {
  return new Promise((resolve, reject) => {
    const data = body ? JSON.stringify(body) : '';
    const options = {
      hostname: 'localhost',
      port: 3000,
      path: endpoint,
      method: method,
      headers: body ? {
        'Content-Type': 'application/json',
        'Content-Length': data.length
      } : {}
    };
    
    const req = http.request(options, (res) => {
      let responseData = '';
      res.on('data', chunk => responseData += chunk);
      res.on('end', () => {
        try {
          resolve(JSON.parse(responseData));
        } catch (e) {
          resolve(responseData);
        }
      });
    });
    
    req.on('error', reject);
    if (data) req.write(data);
    req.end();
  });
}

function parseArgs(args) {
  const opts = {
    command: 'server',
    subcommand: null,
    url: null,
    depth: 2,
    useServer: false,
    mappingsFile: null,
    mappingsJson: null,
    port: 3000
  };
  
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    
    if (arg === '-d' || arg === '--depth') {
      opts.depth = parseInt(args[++i]);
    } else if (arg === '--server') {
      opts.useServer = true;
    } else if (arg === '-p' || arg === '--port') {
      opts.port = parseInt(args[++i]);
    } else if (arg === 'server') {
      opts.command = 'server';
      if (args[i + 1] && ['start', 'stop', 'status'].includes(args[i + 1])) {
        opts.subcommand = args[++i];
      } else {
        opts.subcommand = 'start';
      }
      // Next args after start can be port or mappings
      while (i + 1 < args.length) {
        const next = args[i + 1];
        if (!isNaN(next)) {
          opts.port = parseInt(args[++i]);
        } else if (fs.existsSync(next) || next.startsWith('{')) {
          if (fs.existsSync(next)) {
            opts.mappingsFile = args[++i];
          } else {
            try {
              opts.mappingsJson = JSON.parse(args[++i]);
            } catch (e) {
              break;
            }
          }
        } else {
          break;
        }
      }
    } else if (arg === 'mappings') {
      opts.command = 'mappings';
      if (args[i + 1] && ['get', 'set', 'clear'].includes(args[i + 1])) {
        opts.subcommand = args[++i];
      } else {
        opts.subcommand = 'get';
      }
      // For mappings set, rest is the mappings data
      if (opts.subcommand === 'set' && i + 1 < args.length) {
        const next = args[++i];
        if (fs.existsSync(next)) {
          opts.mappingsFile = next;
        } else {
          try {
            opts.mappingsJson = JSON.parse(next);
          } catch (e) {
            console.error('Error: Invalid JSON for mappings');
            process.exit(1);
          }
        }
      }
    } else if (arg === 'expand' || arg === 'compact') {
      opts.command = arg;
    } else if (!opts.url) {
      opts.url = arg;
    }
  }
  
  return opts;
}

async function main() {
  const args = process.argv.slice(2);
  
  if (args.length === 0) {
    console.error('Usage:');
    console.error('  ldr server [start|stop|status] [port] [mappings.json]');
    console.error('  ldr mappings [get|set|clear] [mappings.json|json]');
    console.error('  ldr [expand|compact] <url> [-d depth] [--server]');
    console.error('');
    console.error('Examples:');
    console.error('  ldr server start 3000 mappings.json');
    console.error('  ldr server start 8080');
    console.error('  ldr mappings set mappings.json');
    console.error('  ldr mappings set \'{"old:*":"https://new/${rest}"}\'');
    console.error('  ldr compact <url> -d 3 --server');
    process.exit(1);
  }
  
  const opts = parseArgs(args);
  
  // Server commands
  if (opts.command === 'server') {
    if (opts.subcommand === 'start') {
      if (isServerRunning()) {
        console.log('Server already running');
        process.exit(0);
      }
      
      // If mappingsJson provided, need to start server then set mappings
      const pid = await startServer(opts.port, opts.mappingsFile);
      console.log(`Server started (PID: ${pid}) on port ${opts.port}`);
      
      if (opts.mappingsJson) {
        await new Promise(resolve => setTimeout(resolve, 500));
        try {
          const result = await apiRequest('POST', '/mappings', { mappings: opts.mappingsJson });
          console.log(`Mappings set: ${result.count} rules`);
        } catch (e) {
          console.error('Warning: Failed to set mappings:', e.message);
        }
      }
      
      console.log(`Stop with: ldr server stop or pkill ldr-server`);
      process.exit(0);
    } else if (opts.subcommand === 'stop') {
      if (!isServerRunning()) {
        console.log('Server not running');
        process.exit(0);
      }
      const pid = parseInt(fs.readFileSync(PID_FILE, 'utf8'));
      process.kill(pid, 'SIGTERM');
      fs.unlinkSync(PID_FILE);
      console.log('Server stopped');
      process.exit(0);
    } else if (opts.subcommand === 'status') {
      if (isServerRunning()) {
        const pid = parseInt(fs.readFileSync(PID_FILE, 'utf8'));
        console.log(`Server running (PID: ${pid})`);
      } else {
        console.log('Server not running');
      }
      process.exit(0);
    }
    return;
  }
  
  // Mappings commands
  if (opts.command === 'mappings') {
    if (!isServerRunning()) {
      console.error('Error: Server not running. Start with: ldr server start');
      process.exit(1);
    }
    
    if (opts.subcommand === 'get') {
      const result = await apiRequest('GET', '/mappings');
      console.log(JSON.stringify(result.mappings, null, 2));
      process.exit(0);
    } else if (opts.subcommand === 'set') {
      if (opts.mappingsFile) {
        const result = await apiRequest('POST', '/mappings', { file: opts.mappingsFile });
        console.log(result.message);
      } else if (opts.mappingsJson) {
        const result = await apiRequest('POST', '/mappings', { mappings: opts.mappingsJson });
        console.log(result.message);
      } else {
        console.error('Error: Mappings file or JSON required');
        process.exit(1);
      }
      process.exit(0);
    } else if (opts.subcommand === 'clear') {
      const result = await apiRequest('DELETE', '/mappings');
      console.log(`Cleared ${result.cleared} mappings`);
      process.exit(0);
    }
    return;
  }
  
  // Expand/compact commands
  if (!opts.url) {
    console.error('Error: URL required');
    process.exit(1);
  }
  
  try {
    let result;
    let serverStarted = false;
    
    if (opts.useServer) {
      if (!isServerRunning()) {
        console.error('Starting server...');
        await startServer(opts.port, opts.mappingsFile);
        serverStarted = true;
        console.error('Server started');
      }
      
      // Set mappings if provided
      if (opts.mappingsJson) {
        await apiRequest('POST', '/mappings', { mappings: opts.mappingsJson });
      }
      
      result = await useServer(opts.url, opts.depth, opts.command);
    } else {
      // Standalone mode
      if (opts.command === 'expand') {
        result = await expandRecursive(jsonld, opts.url, opts.depth);
      } else {
        result = await compactJsonLd(jsonld, opts.url, opts.depth);
      }
    }
    
    console.log(JSON.stringify(result, null, 2));
    
    if (serverStarted) {
      console.error('Server running in background');
      console.error('Stop with: ldr server stop');
    }
  } catch (error) {
    console.error('Error:', error.message);
    process.exit(1);
  }
}

main();
